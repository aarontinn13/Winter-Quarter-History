expertises = ["Novice", "Beginner", "Intermediate", "Proficient", "Experienced", "Advanced"]
for i in expertises:
    print(i)

print('\n************************************************************************\n')

expertises_iterator = iter(expertises)
print(next(expertises_iterator))
print(next(expertises_iterator))
print(next(expertises_iterator))
print(next(expertises_iterator))
print(next(expertises_iterator))
print(next(expertises_iterator))

print('\n************************************************************************\n')
expertises_iterator1 = iter(expertises)
while expertises_iterator1:
    try:
        expertises_iterator2 = next(expertises_iterator1)
        print(expertises_iterator2)
    except StopIteration:
        break

'''
On the surface generators in Python look like functions, but there is both a 
syntactic and a semantic difference. One distinguishing characteristic is the 
yield statements. The yield statement turns a functions into a generator. A 
generator is a function which returns a generator object. This generator object 
can be seen like a function which produces a sequence of results instead of a 
single object. This sequence of values is produced by iterating over it, e.g. 
with a for loop. The values, on which can be iterated, are created by using the 
yield statement. The value created by the yield statement is the value following 
the yield keyword. The execution of the code stops when a yield statement has 
been reached. The value behind the yield will be returned. The execution of the 
generator is interrupted now. As soon as "next" is called again on the generator 
object, the generator function will resume execution right after the yield 
statement in the code, where the last call exited. The execution will continue 
in the state in which the generator was left after the last yield. This means 
that all the local variables still exists, because they are automatically saved 
between calls. This is a fundamental difference to functions: functions always 
start their execution at the beginning of the function body, regardless where they 
had left in previous calls. They don't have any static or persistent values. 
There may be more than one yield statement in the code of a generator or the yield 
statement might be inside the body of a loop. If there is a return statement in 
the code of a generator, the execution will stop with a StopIteration exception 
error if this code is executed by the Python interpreter. The word "generator" 
is sometimes ambiguously used to mean both the generator function itself and the 
objects which are generated by a generator. 
'''

def fibonacci(n):
    """ A generator for creating the Fibonacci numbers """
    a, b, counter = 0, 1, 0
    while True:
        if (counter > n):
            break
        yield a
        a, b = b, a + b
        counter += 1
f = fibonacci(5)
for x in f:
    print(x,' ', end='')

#or

def fibonacci():
    """Generates an infinite sequence of Fibonacci numbers on demand"""
    a, b = 0, 1
    while True:
        yield a
        a, b = b, a + b

f = fibonacci()

counter = 0
for x in f:
    print(x, " ", end="")
    counter += 1
    if (counter > 10):
        break

'''
Generators can not only send objects but also receive objects. Sending a 
message, i.e. an object, into the generator can be achieved by applying 
the send method to the generator object. Be aware of the fact that send 
both sends a value to the generator and returns the value yielded by the 
generator. We will demonstrate this behavior in the following simple example 
of a coroutine:
'''

print('\n************************************************************************\n')

def simple_coroutine():
    print("coroutine has been started!")
    x = yield
    print("coroutine received: ", x)

cr = simple_coroutine()
print(next(cr))

print('\n************************************************************************\n')

def infinite_looper(objects):
    count = 0
    while True:
        if count >= len(objects):                   #objects len = 24
            count = 0
        message = yield objects[count]              #message = string index
        if message != None:
            count = 0 if message < 0 else message
        else:
            count += 1

x = infinite_looper("A string with some words")
print(next(x))
print(next(x))
print(next(x))
print(next(x))

print('\n************************************************************************\n')

'''
The throw() method raises an exception at the point where the 
generator was paused, and returns the next value yielded by the 
generator. It raises StopIteration if the generator exits 
without yielding another value. The generator has to catch the 
passed-in exception, otherwise the exception will be propagated 
to the caller. The infinite_looper from our previous example 
keeps yielding the elements of the sequential data, but we don't 
have any information about the index or the state of the 
variable "count". We can get this information by throwing an 
exception with the "throw" method. We catch this exception inside 
of the generator and print the value of "count":
'''

def infinite_looper(objects):
    count = 0
    while True:
        if count >= len(objects):
            count = 0
        try:
            message = yield objects[count]
        except Exception:
            print("index: " + str(count))
        if message != None:
            count = 0 if message < 0 else message
        else:
            count += 1


looper = infinite_looper("Python")
print(next(looper))
print(next(looper))
print(looper.throw(Exception))
print(next(looper))

print('\n************************************************************************\n')

from functools import wraps

def get_ready(gen):
    """
    Decorator: gets a generator gen ready
    by advancing to first yield statement
    """

    @wraps(gen)
    def generator(*args, **kwargs):
        g = gen(*args, **kwargs)
        next(g)
        return g

    return generator

@get_ready
def infinite_looper(objects):
    count = -1
    message = yield None
    while True:
        count += 1
        if message != None:
            count = 0 if message < 0 else message
        if count >= len(objects):
            count = 0
        message = yield objects[count]

x = infinite_looper("abcdef")
print(next(x))
print(x.send(4))
print(next(x))
print(next(x))
print(x.send(5))
print(next(x))


print('\n************************************************************************\n')


'''
The yield from <expr> statement can be used inside the body of a generator. 
<expr> has to be an expression evaluating to an iterable, from which an 
iterator will be extracted.

The iterator is run to exhaustion, i.e. until it encounters a StopIteration 
exception. This iterator yields and receives values to or from the caller of 
the generator, i.e. the one which contains the yield from statement.

We can learn from the following example by looking at the two generators 
'gen1' and 'gen2' that yield from is substituting the for loops of 'gen1':
'''

def gen1():
    for char in "Python":
        yield char
    for i in range(5):
        yield i

def gen2():
    yield from "Python"
    yield from range(5)

g1 = gen1()
g2 = gen2()
print("g1: ", end=", ")
for x in g1:
    print(x, end=", ")
print("\ng2: ", end=", ")
for x in g2:
    print(x, end=", ")
print()

print('\n************************************************************************\n')

'''
The benefit of a yield from statement can be seen as a way to split a 
generator into multiple generators. That's what we have done in our previous 
example and we will demonstrate this more explicitely in the following example:
'''


def cities():
    for city in ["Berlin", "Hamburg", "Munich", "Freiburg"]:
        yield city

def squares():
    for number in range(10):
        yield number ** 2

def generator_all_in_one():
    for city in cities():
        yield city
    for number in squares():
        yield number

def generator_splitted():
    yield from cities()
    yield from squares()


lst1 = [el for el in generator_all_in_one()]
lst2 = [el for el in generator_splitted()]
print(lst1)
print(lst2)
print(lst1 == lst2)

print('\n************************************************************************\n')

def subgenerator():
    yield 1
    return 42

def delegating_generator():
    x = yield from subgenerator()
    print(x)

for x in delegating_generator():
    print(x)

print('\n************************************************************************\n')

'''
Recursive Generators
'''
def permutations(items):
    n = len(items)
    if n==0: yield []
    else:
        for i in range(len(items)):
            for cc in permutations(items[:i]+items[i+1:]):
                yield [items[i]]+cc

for p in permutations(['r','e','d']):
    print(''.join(p))
for p in permutations(list("game")):
    print(''.join(p) + ", ", end="")

'''
Another Example which is easier than above!
'''

import itertools
perms = itertools.permutations(['r','e','d'])
print(perms)
print(list(perms))

print('\n************************************************************************\n')

def k_permutations(items, n):
    if n == 0:
        yield []
    else:
        for item in items:                                  #a,4 b,3 c,2 d,1
            for kp in k_permutations(items, n - 1):         #abcd ,321
                if item not in kp:
                    yield [item] + kp


for kp in k_permutations("abcd", 4):
    print(kp)

print('\n************************************************************************\n')


'''
Generator of Generators
'''

def fibonacci():
    """Ein Fibonacci-Zahlen-Generator"""
    a, b = 0, 1
    while True:
        yield a
        a, b = b, a + b

def firstn(g, n):
	for i in range(n):
		yield next(g)

print(list(firstn(fibonacci(), 10)))